using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Humanizer;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;

namespace CoreSharp.NHibernate.SourceGenerator
{
    [Generator]
    public class NHibernateGenerator : ISourceGenerator
    {
        protected static readonly SymbolDisplayFormat SymbolDisplayFormat = new SymbolDisplayFormat(typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces);
        protected IList<string> ValidTypes = new List<string>() { "CoreSharp.DataAccess.IEntity", "CoreSharp.DataAccess.ICodeList" };

        public void Initialize(GeneratorInitializationContext context)
        {
#if DEBUG
            if (!Debugger.IsAttached)
            {
                // Debugger.Launch();
            }
#endif
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            try
            {
                if (context.SyntaxReceiver is not SyntaxReceiver receiver)
                {
                    return;
                }

                var classSymbols = GetClassSymbols(context.Compilation, receiver);
                foreach (var classSymbol in classSymbols)
                {
                    var properties = classSymbol.GetMembers().OfType<IPropertySymbol>()
                        .Where(x => !x.ExplicitInterfaceImplementations.Any() && !x.Name.Contains("."));
                    var methods = classSymbol.GetMembers().OfType<IMethodSymbol>();
                    var modified = false;

                    foreach (var propertySymbol in properties)
                    {
                        var propertyInterfaces = propertySymbol.Type.AllInterfaces;
                        var namedTypeSymbol = propertySymbol.Type as INamedTypeSymbol;

                        if (propertySymbol.SetMethod == null)
                        {
                            continue;
                        }

                        if (!(namedTypeSymbol?.IsGenericType == true &&
                              (propertySymbol.Type.Name == "IEnumerable"
                               || propertySymbol.Type.Name == "ISet"
                               || propertySymbol.Type.Name == "IList"
                               || propertySymbol.Type.Name == "HashSet"
                               || propertySymbol.Type.Name == "List"
                               || propertyInterfaces.Any(x =>
                                   x.Name == "ISet" || x.Name == "IList" || x.Name == "IEnumerable"))
                              && propertySymbol.Type.Kind != SymbolKind.ArrayType))
                        {
                            continue;
                        }

                        var propertyType = (INamedTypeSymbol)propertySymbol.Type;

                        var parentAttribute = propertySymbol.GetAttributes().SingleOrDefault(x => x.AttributeClass.Name == "ParentAttribute");
                        var parentPropertyName = parentAttribute?.ConstructorArguments.Single().Value.ToString() ?? classSymbol.Name;
                        var childType = propertyType.TypeArguments.Single();
                        var childTypeName = childType.Name;
                        var propertyName = propertySymbol.Name;
                        var propertyNameSingular = propertyName.Singularize();
                        var methodNames = new[] { $"Add{propertyNameSingular}", $"Remove{propertyNameSingular}", $"Clear{propertyName}" };
                        var notFound = methodNames.Where(x => !methods.Any(m => m.Name == x &&
                            (m.Name == $"Clear{propertyName}" || (m.Parameters.Length == 1 && SymbolEqualityComparer.Default.Equals(m.Parameters[0].Type, childType))))).ToList();

                        if (!notFound.Any())
                        {
                            continue;
                        }

                        modified = true;
                        var addMethod = GenerateAddMethod(notFound, propertyNameSingular, classSymbol, childTypeName, propertySymbol, parentPropertyName);
                        var removeMethod = GenerateRemoveMethod(notFound, propertyNameSingular, classSymbol, childTypeName, propertySymbol, parentPropertyName);
                        var clearMethod = GenerateClearMethod(notFound, propertyName, propertySymbol, classSymbol, propertyNameSingular);

                        var source = $@"//----------------------
// <auto-generated>
//	Generated by NHibernateGenerator
// </auto-generated>
//----------------------
using System;
using System.Linq;
using CoreSharp.NHibernate;
using {childType.ContainingNamespace};

namespace {classSymbol.ContainingNamespace}
{{
public static partial class {classSymbol.Name}Extensions
{{
    {addMethod}
    {removeMethod}
    {clearMethod}
}}
}}
";
                        var desiredFileName = $"{classSymbol.Name}.{propertySymbol.Name}.Methods.cs";
                        var sourceText = SourceText.From(source, Encoding.UTF8); // If no encoding specified then SourceText is not debugable

                        context.AddSource(desiredFileName, sourceText);
                    }

                    if (modified)
                    {
                        var syntax = classSymbol.DeclaringSyntaxReferences
                            .First().SyntaxTree.GetRoot().FindNode(classSymbol.Locations.First().SourceSpan) as ClassDeclarationSyntax;
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
            }
        }

        private static string GenerateClearMethod(List<string> notFound, string propertyName, IPropertySymbol propertySymbol, INamedTypeSymbol classSymbol, string propertyNameSingular)
        {
            return notFound.Contains($"Clear{propertyName}") ? @$"
        public static void Clear{propertySymbol.Name}(this {classSymbol.Name} entity)
        {{
            foreach (var item in entity.{propertySymbol.Name}.ToList())
            {{
                entity.Remove{propertyNameSingular}(item);
            }}
        }}
" : "";
        }

        private static string GenerateRemoveMethod(List<string> notFound, string propertyNameSingular, INamedTypeSymbol classSymbol, string childTypeName, IPropertySymbol propertySymbol, string parentPropertyName)
        {
            return notFound.Contains($"Remove{propertyNameSingular}") ? @$"
        public static void Remove{propertyNameSingular}(this {classSymbol.Name} entity, {childTypeName} item)
        {{
            entity.RemoveOneToMany(o => o.{propertySymbol.Name}, item, o => o.{parentPropertyName});
        }}
" : "";
        }

        private static string GenerateAddMethod(List<string> notFound, string propertyNameSingular, INamedTypeSymbol classSymbol,
            string childTypeName, IPropertySymbol propertySymbol, string parentPropertyName)
        {
            var addMethod = notFound.Contains($"Add{propertyNameSingular}")
                ? @$"
        public static void Add{propertyNameSingular}(this {classSymbol.Name} entity, {childTypeName} item)
        {{
            entity.AddOneToMany(o => o.{propertySymbol.Name}, item, o => o.{parentPropertyName}, o => o.Remove{propertyNameSingular});
        }}
"
                : "";
            return addMethod;
        }

        private static INamedTypeSymbol GetClassSymbol(Compilation compilation, ClassDeclarationSyntax clazz)
        {
            var model = compilation.GetSemanticModel(clazz.SyntaxTree);
            var classSymbol = model.GetDeclaredSymbol(clazz)!;
            return classSymbol;
        }

        private IList<INamedTypeSymbol> GetClassSymbols(Compilation compilation, SyntaxReceiver receiver)
        {
            // var classDeclarationSyntaxes = compilation.SyntaxTrees.SelectMany(x => x.GetRoot().DescendantNodes().OfType<ClassDeclarationSyntax>()).ToList();
            var classSymbols = new List<INamedTypeSymbol>();
            foreach (var clazz in receiver.CandidateClasses)
            {
                var classSymbol = GetClassSymbol(compilation, clazz);
                if (IsValidType(classSymbol) && !classSymbols.Contains(classSymbol))
                {
                    classSymbols.Add(classSymbol);
                }
            }

            return classSymbols;
        }

        private bool IsValidType(INamedTypeSymbol cls)
        {
            var interfaces = cls.AllInterfaces.Select(x => x.ToDisplayString(SymbolDisplayFormat));

            if (interfaces.Any(x => ValidTypes.Contains(x)))
            {
                return true;
            }

            return false;
        }

        protected bool IsValidType(SyntaxNodeAnalysisContext nodeContext)
        {
            var classNode = nodeContext.Node.Parent as ClassDeclarationSyntax;

            if (classNode == null)
            {
                return false;
            }

            var symbol = ModelExtensions.GetDeclaredSymbol(nodeContext.SemanticModel, classNode) as INamedTypeSymbol;
            var interfaces = symbol?.AllInterfaces.Select(x => x.ToDisplayString(SymbolDisplayFormat));

            if (interfaces?.Any(x => ValidTypes.Contains(x)) == true)
            {
                return true;
            }

            return false;
        }

        protected bool IsValidType(ClassDeclarationSyntax classSyntax, SemanticModel semanticModel)
        {
            var classNode = classSyntax;

            if (classNode == null)
            {
                return false;
            }

            var symbol = ModelExtensions.GetDeclaredSymbol(semanticModel, classNode) as INamedTypeSymbol;
            var interfaces = symbol?.AllInterfaces.Select(x => x.ToDisplayString(SymbolDisplayFormat));

            if (interfaces?.Any(x => ValidTypes.Contains(x)) == true)
            {
                return true;
            }

            return false;
        }
    }
}
